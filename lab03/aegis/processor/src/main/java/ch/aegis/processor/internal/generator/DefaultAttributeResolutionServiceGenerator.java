package ch.aegis.processor.internal.generator;

import ch.aegis.processor.internal.util.AnnotationProcessorContext;
import com.palantir.javapoet.AnnotationSpec;
import com.palantir.javapoet.ClassName;
import com.palantir.javapoet.FieldSpec;
import com.palantir.javapoet.JavaFile;
import com.palantir.javapoet.MethodSpec;
import com.palantir.javapoet.ParameterizedTypeName;
import com.palantir.javapoet.TypeSpec;
import com.palantir.javapoet.TypeVariableName;
import com.palantir.javapoet.WildcardTypeName;
import java.io.IOException;
import java.util.Collection;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Set;
import javax.lang.model.element.Modifier;

/**
 * Generates the DefaultAttributeResolutionService class implementation. This class is responsible
 * for resolving attributes using providers and resolvers.
 *
 * @author Lo√Øc Herman
 * @author Massimo Stefani
 * @author Quentin Surdez
 * @since 1.0
 */
public final class DefaultAttributeResolutionServiceGenerator {

    private static final String GENERATED_CLASS_NAME = "DefaultAttributeResolutionService";
    private static final String GENERATED_PACKAGE = "ch.aegis.service";

    private static final ClassName CONCURRENT_REFERENCE_MAP = ClassName.get(
        "org.springframework.util",
        "ConcurrentReferenceHashMap"
    );

    private final AnnotationProcessorContext context;

    private DefaultAttributeResolutionServiceGenerator(AnnotationProcessorContext context) {
        this.context = context;
    }

    /**
     * Generates the DefaultAttributeResolutionService class file.
     *
     * @throws IOException if the file cannot be written
     */
    public void generate() throws IOException {
        var classBuilder = createClassBuilder();
        addFields(classBuilder);
        addConstructor(classBuilder);
        addMethods(classBuilder);
        addInnerClasses(classBuilder);

        var javaFile = JavaFile.builder(GENERATED_PACKAGE, classBuilder.build())
            .skipJavaLangImports(true)
            .build();

        javaFile.writeTo(context.getFiler());
    }

    private TypeSpec.Builder createClassBuilder() {
        return TypeSpec.classBuilder(GENERATED_CLASS_NAME)
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(ClassName.get("org.springframework.stereotype", "Service"))
            .addAnnotation(
                AnnotationSpec.builder(SuppressWarnings.class)
                    .addMember("value", "$S", "rawtypes")
                    .build()
            )
            .addAnnotation(GeneratorUtils.createGeneratedAnnotation())
            .addSuperinterface(ClassName.get("ch.aegis.contract", "AttributeResolutionService"))
            .addJavadoc(
                """
                Auto-generated service implementation for the {@link AttributeResolutionService} interface, which
                resolves attributes using {@link AttributeProvider}s and {@link AttributeResolver}s from the
                application context.

                @generated by AttributeResolutionServiceGenerator
                """
            );
    }

    private void addFields(TypeSpec.Builder classBuilder) {
        // Add collection fields
        classBuilder.addField(
            FieldSpec.builder(
                ParameterizedTypeName.get(
                    ClassName.get(Collection.class),
                    ClassName.get("ch.aegis.contract", "AttributeProvider")
                ),
                "attributeProviders",
                Modifier.PRIVATE,
                Modifier.FINAL
            ).build()
        );

        classBuilder.addField(
            FieldSpec.builder(
                ParameterizedTypeName.get(
                    ClassName.get(Collection.class),
                    ClassName.get("ch.aegis.contract", "AttributeResolver")
                ),
                "attributeResolvers",
                Modifier.PRIVATE,
                Modifier.FINAL
            ).build()
        );

        // Add cache fields
        classBuilder.addField(
            FieldSpec.builder(
                ParameterizedTypeName.get(
                    ClassName.get(Map.class),
                    ClassName.get(Class.class),
                    ClassName.get("ch.aegis.contract", "AttributeProvider")
                ),
                "providerCache",
                Modifier.PRIVATE,
                Modifier.FINAL
            )
                .initializer("new $T<>()", CONCURRENT_REFERENCE_MAP)
                .build()
        );

        classBuilder.addField(
            FieldSpec.builder(
                ParameterizedTypeName.get(
                    ClassName.get(Map.class),
                    ClassName.get("", "ConvertiblePair"),
                    ClassName.get("ch.aegis.contract", "AttributeResolver")
                ),
                "resolverCache",
                Modifier.PRIVATE,
                Modifier.FINAL
            )
                .initializer("new $T<>()", CONCURRENT_REFERENCE_MAP)
                .build()
        );
    }

    private void addConstructor(TypeSpec.Builder classBuilder) {
        classBuilder.addMethod(
            MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addParameter(
                    ParameterizedTypeName.get(
                        ClassName.get(Collection.class),
                        ClassName.get("ch.aegis.contract", "AttributeProvider")
                    ),
                    "attributeProviders"
                )
                .addParameter(
                    ParameterizedTypeName.get(
                        ClassName.get(Collection.class),
                        ClassName.get("ch.aegis.contract", "AttributeResolver")
                    ),
                    "attributeResolvers"
                )
                .addStatement("this.attributeProviders = attributeProviders")
                .addStatement("this.attributeResolvers = attributeResolvers")
                .build()
        );
    }

    private void addMethods(TypeSpec.Builder classBuilder) {
        // Add getProvider method
        classBuilder.addMethod(
            MethodSpec.methodBuilder("getProvider")
                .addModifiers(Modifier.PRIVATE)
                .returns(ClassName.get("ch.aegis.contract", "AttributeProvider"))
                .addParameter(Class.class, "attributeType")
                .addStatement(
                    """
                    return providerCache.computeIfAbsent(
                        attributeType,
                        type -> attributeProviders.stream()
                            .filter(provider -> provider.getAttributeType().equals(type))
                            .findFirst()
                            .orElse(null)
                    )"""
                )
                .build()
        );

        // Add getResolver method
        classBuilder.addMethod(
            MethodSpec.methodBuilder("getResolver")
                .addModifiers(Modifier.PRIVATE)
                .returns(ClassName.get("ch.aegis.contract", "AttributeResolver"))
                .addParameter(Class.class, "sourceType")
                .addParameter(Class.class, "targetType")
                .addStatement(
                    """
                    return resolverCache.computeIfAbsent(
                        new ConvertiblePair(sourceType, targetType),
                        pair -> attributeResolvers.stream()
                            .filter(resolver -> (
                                resolver.getSourceAttributeType().equals(pair.sourceType)
                                    && resolver.getResolvedAttributeType().equals(pair.targetType)
                            ))
                            .findAny()
                            .orElse(null)
                    )"""
                )
                .build()
        );

        // Add resolve method
        classBuilder.addMethod(
            MethodSpec.methodBuilder("resolve")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addTypeVariable(
                    TypeVariableName.get("R", ClassName.get("ch.aegis.model", "Attribute"))
                )
                .returns(TypeVariableName.get("R"))
                .addParameter(
                    ParameterizedTypeName.get(
                        ClassName.get(Set.class),
                        WildcardTypeName.subtypeOf(ClassName.get("ch.aegis.model", "Attribute"))
                    ),
                    "params"
                )
                .addParameter(
                    ParameterizedTypeName.get(
                        ClassName.get(Class.class),
                        TypeVariableName.get("R")
                    ),
                    "targetType"
                )
                .addJavadoc(
                    """
                    First attempts to find an {@link AttributeProvider} for the attribute, if none is found it
                    will attempt to find an {@link AttributeResolver} that can convert any of the intercepted
                    endpoint method arguments to an attribute (though if there are multiple resolvers that can
                    resolve the same argument, it will throw an exception).

                    @inheritDoc
                    """
                )
                .addCode(
                    """
                    // 1. Attempt to find an AttributeProvider
                    var provider = getProvider(targetType);
                    if (provider != null) {
                        return targetType.cast(provider.provide());
                    }

                    // 2. Attempt to find an AttributeResolver
                    var resolvers = params.stream().flatMap(param -> $1T
                        .ofNullable(getResolver(param.getClass(), targetType))
                        .map(resolver -> new ResolverPair(resolver, param))
                        .stream()
                    ).toList();

                    if (resolvers.size() > 1) {
                        throw new IllegalStateException(
                            "Multiple arguments can be resolved to the same required attribute type, if there are no other ways to disambiguate argument types, then you should add an explicit attribute override through the corresponding policy annotation."
                        );
                    }

                    if (resolvers.isEmpty()) {
                        throw new $2T(
                            "No attribute resolver found for the given parameters"
                        );
                    }

                    var resolverPair = resolvers.getFirst();
                    return resolverPair.resolve(targetType);
                    """,
                    Optional.class,
                    NoSuchElementException.class
                )
                .build()
        );
    }

    private void addInnerClasses(TypeSpec.Builder classBuilder) {
        // Add ConvertiblePair record
        classBuilder.addType(
            TypeSpec.recordBuilder("ConvertiblePair")
                .addModifiers(Modifier.PRIVATE)
                .recordConstructor(
                    MethodSpec.constructorBuilder()
                        .addParameter(Class.class, "sourceType")
                        .addParameter(Class.class, "targetType")
                        .build()
                )
                .build()
        );

        // Add ResolverPair record
        var resolverPair = TypeSpec.recordBuilder("ResolverPair")
            .addModifiers(Modifier.PRIVATE)
            .recordConstructor(
                MethodSpec.constructorBuilder()
                    .addParameter(
                        ClassName.get("ch.aegis.contract", "AttributeResolver"),
                        "resolver"
                    )
                    .addParameter(ClassName.get("ch.aegis.model", "Attribute"), "source")
                    .build()
            )
            .addMethod(
                MethodSpec.methodBuilder("resolve")
                    .addModifiers(Modifier.PUBLIC)
                    .addTypeVariable(
                        TypeVariableName.get("R", ClassName.get("ch.aegis.model", "Attribute"))
                    )
                    .returns(TypeVariableName.get("R"))
                    .addParameter(
                        ParameterizedTypeName.get(
                            ClassName.get(Class.class),
                            TypeVariableName.get("R")
                        ),
                        "targetType"
                    )
                    .addAnnotation(
                        AnnotationSpec.builder(SuppressWarnings.class)
                            .addMember("value", "$S", "unchecked")
                            .build()
                    )
                    .addStatement("return targetType.cast(resolver.resolve(source))")
                    .build()
            )
            .build();

        classBuilder.addType(resolverPair);
    }

    /**
     * Creates a new instance of AttributeResolutionServiceGenerator from the given context.
     *
     * @param context the annotation processor context
     * @return a new AttributeResolutionServiceGenerator instance
     */
    public static DefaultAttributeResolutionServiceGenerator fromContext(
        AnnotationProcessorContext context
    ) {
        return new DefaultAttributeResolutionServiceGenerator(context);
    }
}
